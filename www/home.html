<!DOCTYPE html>
<style>
  h5 {
    font-weight: bold;
  }
#algo {
  border: 1px solid;
  padding: 10px;
  box-shadow: 10px 10px 10px blue;
}
span.frac {
  display: inline-block;
  text-align: center;
  vertical-align: middle;
}
span.frac > sup, span.frac > sub {
  display: block;
  font: inherit;
  padding: 0 0.3em;
}
span.frac > sup {border-bottom: 0.08em solid;}
span.frac > span {display: none;}

/* The Modal (background) */
.modal {
  display: none; /* Hidden by default */
  position: fixed; /* Stay in place */
  z-index: 1; /* Sit on top */
  padding-top: 100px; /* Location of the box */
  left: 0;
  top: 0;
  width: 100%; /* Full width */
  height: 100%; /* Full height */
  overflow: auto; /* Enable scroll if needed */
  background-color: rgb(0,0,0); /* Fallback color */
  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
}

/* Modal Content */
.modal-content {
  background-color: #fefefe;
  margin: auto;
  padding: 20px;
  border: 1px solid #888;
  width: 80%;
}

/* The Close Button */
.close {
  color: #aaaaaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
}

.close:hover,
.close:focus {
  color: #000;
  text-decoration: none;
  cursor: pointer;
}
</style>

<body>
<h3>Welcome to <i>GraphApp</i>!</h3>
<p><i>GraphApp</i> is a Shiny application that helps to implement the graphical approach for multiple test procedures. 
The key idea is to express the resulting multiple test procedures by directed, weighted graphs, where each node corresponds to an elementary hypothesis, together with a simple algorithm to generate such graphs while sequentially testing the individual hypotheses. 

The application is a companion to the following article:
<b><li>Bretz, F., Posch, M., Glimm, E., Klinglmueller, F., Maurer, W., & Rohmeyer, K. (2011). Graphical approaches for multiple comparison procedures using weighted Bonferroni, Simes, or parametric tests. <i>Biometrical Journal</i>, 53(6), 894-913. <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/bimj.201000239">PDF</a></li></b>

<h3>How to use this application</h3>
You should navigate this site using the header tabs:
<br>
<i class="glyphicon glyphicon-home"></i> <b>Home</b>: 
General description of this Shiny application and some learning materials.
<br>
<i class="glyphicon glyphicon-pencil"></i> <b>Draw</b>: Draw the test procedure by yourself with nodes and edges or corresponding information.
<br>
<i class="glyphicon glyphicon-cog"></i> <b>Examples</b>: The most commonly used procedures or specific tests:<br>
<font face="Verdana">
 <li>Common procedures:</li>
Bonferroni-Holm procedure; Fixed Sequence tests; Fallback procedures</font> 
 <font face="Verdana">
<li>Specific tests:</li>
Simple successive procedure; Parallel gatekeeping procedure</font> 
<br>
<h3>Method</h3>
From a regulatory viewpoint, a flexible and appropriate approach is required for Type-I error control. 
Besides, the corresponding clinical trials always have complex objectives and a hierarchical structure to the hypotheses tested. The graphical approach to hypothesis testing, in this Shiny application is an approach that can satisfy the Type-I error adjustment and reflect the relationships between different hypotheses simultaneously.
The graphical approaches dissociate the <em>underlying weighting strategy </em> and the <em>employed test procedure </em>. Such a separation between the weighting strategy and the test procedure facilitates the application of graphical approach underling varying situations. Technical basis of the graphical approach: the graph defines a closed testing procedure.

Below is an example for the graphical approaches with weighted Bonferroni tests for each intersection hypothesis:
<ul>
  <li>Hypotheses <em>H<sub>1</sub></em>, ..., <em>H<sub>K</sub></em> are represented as nodes</li>
  <li>Split of significance level <em>&alpha;</em> into (<em>&alpha;<sub>1</sub></em>, ...,  <em>&alpha;<sub>K</sub></em>)</li>
  <p>Equivalent formulation of split of <em>&alpha;<sub>i</sub></em> using weights (<em>w<sub>1</sub></em>, ..., <em>w<sub>K</sub></em>) where <em>&sum;<sup>K</sup><sub style="margin-left: 1px">i=1</sub>w<sub>i</sub></em>= 1 and <em>&alpha;<sub>i</sub></em> = <em>&alpha;<em>w<sub>i.</sub></em></em></p>
  <li>'<em>&alpha;</em> propagation' through weighted, directed edges
</li>
<p>If a hypothesis Hi can be rejected at level <em>&alpha;<sub>i</sub></em> (i.e. <em>p<sub>i</sub></em> â‰¤ <em>&alpha;<sub>i</sub></em>), propagate its level <em>&alpha;<sub>i</sub></em> to the remaining (not yet tested) hypotheses, according to a prefixed rule, and continue
testing with the updated <em>&alpha;</em> levels.
</p>
</ul>
With Transition Matrix <em>G</em> and specified weights <em>&omega;<sub>i</sub></em>, the initial graph and final graph can be provided.
Multiple testing procedures for clinical trials are able to address multiple objectives, such as comparison of different treatments, subgroups or endpoints. 
<p>The function <code>gMCP_app()</code> comes to the result of graphical approach of multiple testing. An example is displayed below to show how to use this funciton. </p>
<pre><code class="lang-r">
# the Transition Matrix (Bonferroni-Holm Test)
matrix &lt;- rbind(H1 = c(0, 0.5, 0.5), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H2 = c(0.5, 0, 0.5),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H3 = c(0.5, 0.5, 0)) 
# weights and <i>p</i>-values of individual hypothesis
weights &lt;-  c(1/3, 1/3, 1/3)
pvalues &lt;- c(0.01,0.07,0.02)
gMCP_app(matrix,weights,pvalues, alpha = 0.05,fweights = F)

</code></pre>
On the right panel, the videos show how to work this example by <em>Draw</em> and <em>Example</em> panels. Besides, the R markdown file shows how to work out this example by R code.
<br>


<script>
// Get the modal
var modal = document.getElementById("myModal");
// Get the button that opens the modal
var btn = document.getElementById("myBtn");
// Get the <span> element that closes the modal
var span = document.getElementsByClassName("close")[0];
// When the user clicks the button, open the modal 
btn.onclick = function() {
  modal.style.display = "block";
}
// When the user clicks on <span> (x), close the modal
span.onclick = function() {
  modal.style.display = "none";
}
// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
  if (event.target == modal) {
    modal.style.display = "none";
  }
}
</script>
</body>


